%***************************************************************************
% XSPIF developer's guide -  devguide.tex
% Chapter : Extending XSPIF
% Authors: Remy Muller & Vincent Goudard
%***************************************************************************


\chapter{Extending XSPIF}

\noindent XSPIF can be extended in two ways: adding new standards to it, and adding new features. These two ways are very orthogonal: adding a new standard can be viewed as a vertical approach, as one has to write down the new standard's source file(s). One the other hand, adding a new feature implies a horizontal approach, as the developer has to visit every standard to implement the new feature with respect to each standard conventions.

%-------------------------------------------------------------------------
\section{How to add a standard in XSPIF?}

%........................................................................
\subsection{Modifying xspif.py}
\noindent To be known from XSPIF, the module for the new standard should be imported in the main script \verb|xspif.py| by adding the following line, where \textit{std} stands for the new module's name:

\begin{center}
\textbf{import xspif.\textit{std}}
\end{center}

\noindent The new standard name should be added wherever it has to be placed in \verb|xspif.py|. It should not present any difficulty to do so, by doing the same as what is written for other standards.

%........................................................................
\subsection{Creating a new module}
\noindent The new module should be called after the name of the new standard, and placed in the folder \verb|/xspif|. 

\noindent The output files generated by this module will then automatically be written in a new directory, created where the meta-plugin is stored. For example, if the meta-plugin \verb|text.xspif| is stored in the folder \verb|/metaplugins|, the source code will be generated in the sub-folder:

\begin{center}
\textbf{/\textit{metaplugins}/\textit{test}/\textit{std}/}
\end{center}

\noindent However, and as much as possible, we recommandto follow the main guidelines given in chapter 3, as well as respecting the order of the callbacks implementation: indepedant code, declaration of the parameters, instantiate, deinstantiate, activate, deactivate, parameter's code, controlout routines, process. There is actually no obligation for following that order, but always following the same order helps keeping the XSPIF API clearer.

\noindent The obvious weak point of XSPIF is the lack of a more organized Python code architecture, concerning the translating part. The code is rather linear and many things are duplicated. We tried to add some routine when there was strict duplication, like declaring the states and parameters at the beginning of function for API in C language.

\noindent The function \code{getText(node, label)} is available from the module \verb|parsexml.py|, to get the data of a sub-element (node or attribute) of a given node.\\

\noindent The problem we faced for a better python code, is the fact
that hard-coded parts of the C/C++ code, and variables parts coming
from the meta-plugin are deeply intricated. This made it difficult to
reach a more synthetic Python code, without making it difficult to read.


%-------------------------------------------------------------------------
\section{How to add a feature in XSPIF?}

\noindent We will give here an example: the addition of the controlout feature, used to output control values from the plugin.

%........................................................................
\subsection{Updating the DTD}
\noindent First of all, the feature should be added in the Document Type Definition \verb|xspif.dtd|. Special attention should be given to this, by stating as required only what is really required.

\begin{verbatim}
<!ELEMENT controlout (caption?, comment?)>
<!ATTLIST controlout label      CDATA   #REQUIRED 
                min             CDATA   #REQUIRED
                max             CDATA   #REQUIRED
                type      (float|int)   #REQUIRED
                mapping     (lin|log)   #IMPLIED
                unit            CDATA   #IMPLIED>
\end{verbatim}

\noindent This XML tag has 4 required attributes:

\begin{description}
\item \textbf{label}: which identifies the element, and the possible variables related to this element in the source code to be written.
\item \textbf{min and max}: is necessary when output values are forced to fit within a given range (for a given standard), and thus perform any necessary mapping before outputting these output values.
\item \textbf{type}: is needed to declare the variable type in the plugin
  structure and callbacks, so that the user can handle this
  variable. Note that the value of this element is only float or int
  for now. Note that some plugin API store the parmeters as float
  internally and deliver them to you by casting them in the type
  you've specified.
\end{description}

\noindent Additionnal information tags which are not required for a correct implementation, should be declared as \verb|#IMPLIED|. This information will be used to generate commentaries in the source code, and in the plugin GUI.

\begin{description}
\item \textbf{the caption}: gives the full name of the controlout (meaning something more explicit than the label).
\item \textbf{comments}: can provide additionnal information about this element.
\item \textbf{the mapping}: gives the possibility to have a
  logarithmic mapping. the default mapping being linear.
\end{description}
 
%........................................................................
\subsection{Updating the checking module}

\noindent Then, the feature has to be checked by the sub-module \code{generalCheck} of the module \verb|tools.py|. This sub-module is called by the main script \verb|xspif.py|, and any error that would lead to the writing of bad C/C++ source code should make this module stop and return -1, so that the script can stop immediately.\\
\noindent There are various things that can be checked with this module. The developer can go through the various steps, and add what is needed to check the validity of the data contained in the new element.\\
Please keep in mind that these verifications should still be \textbf{standard-independant} at this stage.\\

\subsubsection{Validity of the label}
\noindent If the new element has a label, the label should be unique to prevent from clashes in variables naming, and it should not contain any wrong character like spaces, commas\ldots etc.\\

\noindent Unicity of the label can be easily checked with the routine \code{checkNotTwiceSameElement}. This function take a list as argument. It returns the first element that would appear twice, zero otherwise.\\

\noindent For our example, we just have to add \verb|controlouts| in the list of elements that own a label:\\

\begin{verbatim}
---------------------- [begin Python code] ----------------------
# Check every label is unique
for tag in [pins, params, states, controlouts]:
    for el in tag:
        labels.append(getText(el,'label'))
labels.append(pluginLabel)

extraLabel = checkNotTwiceSameElement(labels)
if (0 != extraLabel):
    print(T+"Error: label "+extraLabel+" was used more than once")
    return -1
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent Correctness of the label name can be checked with the routine \code{stringHasChar}. This function take a string and a list of wrong characters as arguments. It returns the first wrong character that would appear in the string, zero otherwise.

\begin{verbatim}
---------------------- [begin Python code] ----------------------
# Check labels do not contain bad characters
 WrongCharList = [" ","&","'",'"',"&","#","@","-","*"]
 for myString in labels:
     if ("" == myString):
         print(T+'Error: One of the labels is null!!!')
     WrongChar = stringHasChar(myString, WrongCharList)
     if (WrongChar):
         print(T+"Error: Label '"+l+"' contains bad characher '"+WrongChar+"'")
         return -1
----------------------- [end Python code] -----------------------
\end{verbatim}

\subsubsection{Validity of the min, max and default values}
\noindent Min, max, and default values can be checked with the routine \code{checkMinMaxDefault}. This function take as argument an element that has \verb|min|, \verb|max|, \verb|mapping| and \verb|default| attributes. It will check that:

\begin{itemize}
\item{\verb|min| is stricly less that \verb|max|.}
\item{\verb|min| and \verb|max| are strictly superior than zero if the mapping is \verb|log|.}
\item{\verb|default| fits within \verb|min| and \verb|max|. }
\end{itemize}


%........................................................................
\subsection{Updating the translators}

\noindent Then, this feature should be handled in all the translation
modules. Here after is the example of the addition of the controlout's
handling in various standards.  

\noindent First, we add the following line to get a node list of all
controlout elements:\\ 

\verb|controlouts = domTree.getElementsByTagName('controlout')|


\subsubsection{VST}
\noindent With VST, the only way to output control consist in using MIDI
Continuous Controllers. As most of the MIDI instruments only takes
into account single CC (i.e. 7-bit) we haven't implemented the use of
2 CC to extand the dynamic range to 14-bit.\\
\noindent Implementing controlout into VST firstly consists in declaring a
MIDI out port wich is paradoxaly done by calling \verb|wantEvents()|
inside the \verb|resume()| method and returning \verb|1| to the
following \verb|canDo()| : \verb|''sendVstEvents''| and
\verb|''sendVStMidiEvent''| this done with the follwing python code:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
# Plugin suspend and resume
    
fcpp.write('//-------------------------------------------------------------'+'\n'
           +'void '+pluginLabel+'::resume()'+'\n'
           +'{'+'\n')
    
if controlouts != []:
    fcpp.write(T+'wantEvents();'+'\n')

fcpp.write(T+activateCode+'\n'
           +'}'+'\n'
           +'\n')
----------------------- [end Python code] -----------------------
and further:

---------------------- [begin Python code] ----------------------
fcpp.write('long '+pluginLabel+'::canDo(char* text)'+'\n'
           +'\t'+'{'+'\n' )

if controlouts != []:
    fcpp.write(T+'if (!strcmp (text, "sendVstMidiEvent")) return 1;'+'\n'
               +T+'if (!strcmp (text, "sendVstEvents")) return 1;'+'\n')

fcpp.write('}'+'\n')
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent Now that we have declared a midi Out port we have to handle
the mapping of the control dynamic to the 0-127 range according to the
specified mapping and then send this MIDI event to the host. The
\textit{XSPIF\_CONTROLOUT()} macro is wrapped to the the controlout() method:

\begin{verbatim}
---------------------- [begin C code] ----------------------
#define XSPIF_CONTROLOUT(label, index, value)(controlOut(label,index,value))
----------------------- [end C code] -----------------------
\end{verbatim}


and this method method is defined by the following python code which
takes care of filling a VstMidiEvent structure as defined in the
VSTSDK, for more detailed information on this topic refer to \cite{vst:sdk}:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
if controlouts != []:
    fcpp.write(
        '//-------------------------------------------------------------'+'\n'
        +'// control out'+'\n'
        +'\n'
        +'void '+pluginLabel+'::controlout(long label, long index, float value)'+'\n'
        +'{'+'\n'
        +T+'char out=0;'+'\n'
        +T+'char cc=0;'+'\n'
        +T+'switch(label)'+'\n'
        +T+'{'+'\n')
    
    i = 38 # first MIDI CC that will be used fo control out
    for controlout in controlouts:
        label = getText(controlout,'label')
        max   = label+'Max'
        min   = label+'Min'
        mapping = getText(controlout,'mapping')
        controloutCode = getText(param,'code')
            
        if i >127:
            print 'warning too much controlouts, CC numbers exceed 127'
            return

        fcpp.write(T*2+'case '+label+' :'+'\n' 
                   +T*3+'cc = '+str(i)+';'+'\n')
        i = i+1
                        
        if mapping == 'lin':
            fcpp.write(T*3+'out = 127*((value-'+min+')/('+max+'-'+min+'));'+'\n')            
        elif mapping == 'log':
            fcpp.write(T*3+'out = 127*(log(value/'+min+')/log('+max+'/'+min+'));'+'\n')
                        
    fcpp.write(
        '\n'
        +T*2+'default: return;'+'\n'
        +T+'}'+'\n'
        +'\n'
        +T+'if(index>vector_size)'+'\n'
        +T*2+'index = vector_size;'+'\n'
        +'\n' 
        
        +T+'VstMidiEvent vstEvent;'+'\n'  
        +T+'VstEvents vstEvents; '+'\n' 
        +T+'vstEvents.numEvents =1; '+'\n' 
        +T+'vstEvents.reserved = 0; '+'\n' 
        +T+'vstEvents.events[0] = (VstEvent*)(&vstEvent); '+'\n' 
        +T+'vstEvents.events[1]= NULL; '+'\n'
        +'\n' 
        +T+'memset(&vstEvent, 0, sizeof(vstEvent));'+'\n' 
        +T+'vstEvent.type = kVstMidiType;'+'\n' 
        +T+'vstEvent.byteSize = 24;'+'\n' 
                
        +T+'vstEvent.deltaFrames = index; '+'\n' 
        +T+'vstEvent.midiData[0]=0xb0; // tells it sends midi CC'+'\n' 
        +T+'vstEvent.midiData[1]=cc; '+'\n' 
        +T+'vstEvent.midiData[2]=out; '+'\n' 
        +T+'((AudioEffectX *)this)->sendVstEventsToHost(&vstEvents);'+'\n' 
        +'}'+'\n'
        )
----------------------- [end Python code] -----------------------
\end{verbatim}

\subsubsection{LADSPA}
\noindent In LADSPA, controlouts can be implemented in a very direct way,
 as it just consists in writing a value to a pointer.
\noindent All parameters, audio input and output, and control output 
are declared as ``ports''. For convenience, a list with all these 
ports already exists; we will just add the controlouts to it, 
and they will be declared in the plugin structure:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
ports = audio_ports + param_ports + controlout_ports
                   (...)
fc.write('/* Audio and parameters ports */' + '\n')
for port in ports:
    fc.write('#define PORT_'+port[0].upper()
             +T*2+ str(ports.index(port))+'\n')
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent Then, we will first define the XSPIF\_CONTROLOUT macro, after the \verb|#include|'s, for the parameters' attached code sections. Here the method can be called directly, hence the macros is defined like this:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
if ([] != controlouts):
    fc.write('// Macro for control output' + '\n')
    fc.write('#undef XSPIF_CONTROLOUT'+ '\n'
             '#define XSPIF_CONTROLOUT(dest, index, source)'
             + '(*(dest) = (LADSPA_DATA(source)))'+ '\n')
----------------------- [end Python code] -----------------------
\end{verbatim}


\noindent Finally, we have to declare the controlouts in the \verb|_init| method of the LADSPA API:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
control_nodes = params + controlouts
for cp_node in control_nodes:
    pl = 'PORT_'+ getText(cp_node, 'label').upper()
    fc.write(
        T*2 + '/* Parameters for ' + getText(cp_node, 'caption')+' */' + '\n'
        + T*2 + 'port_descriptors['+ pl + '] =' + '\n')
    if ('param'==cp_node.nodeName):
        fc.write(T*2+' LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;' + '\n')
    elif ('controlout'==cp_node.nodeName):
        fc.write(T*2+' LADSPA_PORT_OUTPUT | LADSPA_PORT_CONTROL;' + '\n')
    fc.write(
        T*2 + 'port_names[' + pl + '] =' + '\n'
        + T*2 + ' strdup("' +  getText(cp_node, 'caption') + '");' + '\n'
        + T*2 + 'port_range_hints[' + pl + '].HintDescriptor =' + '\n'
        + T*2)
----------------------- [end Python code] -----------------------
\end{verbatim}

\subsubsection{PureData}

\noindent In PD, the controlouts will appear as outlets, and values are output via an API specific method called \verb|outlet_float|\footnote{Only float values can be output.}.

\noindent We will first define the XSPIF\_CONTROLOUT macro, after the \verb|#include|'s, for the parameters' attached code sections. Here the method can be called directly, hence the macros is defined like this:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
// Macro for control outputs
#undef XSPIF_CONTROLOUT
#define XSPIF_CONTROLOUT(dest, index, value)(outlet_float(dest, value))
----------------------- [end Python code] -----------------------
\end{verbatim}


\noindent Then we need to declare the controlouts in the object's structure. Each controlout will own:
\begin{itemize}
\item A variable storing the value to be sent to the outlet.
\item An object of type \verb|t_outlet| as defined in the PD API.
\item A clock than can be set in the \textit{process} callback to postpone the output.
\end{itemize}

\begin{verbatim}
---------------------- [begin Python code] ----------------------
fc.write('typedef struct _' + pluginLabelTilde + ' {' + '\n'
               (...)
fc.write(T + '// Pointers to the outlets:\n')
for c_node in controlouts:
    c_label = getText(c_node, 'label')
    c_type  = getText(c_node, 'type')
    fc.write(T + c_type + ' '+ c_label+'Value;'+ '\n')
    fc.write(T + 't_outlet *' + c_label + ';' + '\n')
    fc.write(T + 't_clock *p_'+c_label+'Clock;'+ '\n')
               (...)
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent Then we need a function that will do the output, when called by the clock 
of a given controlout:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
if ([]!=controlouts):
    fc.write('\n' + '\n' + separator)
    fc.write('// Functions for controlouts called by clocks'+'\n')
    for c_node in controlouts:
        c_label = getText(c_node, 'label')
        fc.write('static void '+pluginLabelTilde+'_'+c_label+'('
                 +t_pluginLabel+' *x){'+'\n')
        fc.write(T+'outlet_float(x->'+c_label+', 
                 x->'+c_label+'Value);'+'\n')
    fc.write('}' + '\n')
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent The following function is the one that will be called by the macro
XSPIF\_CONTROLOUT, when called from the process callback. Note that the 
conversion from the sample index to the clock delay (in ms) is done here.

\begin{verbatim}
---------------------- [begin Python code] ----------------------
fc.write('// Function for controlouts : setting the clock'  + '\n')
fc.write('static void '+pluginLabelTilde+'_controlouts('
        +t_pluginLabel
        +' *x, t_outlet *dest, t_float index, t_float value){'+'\n')
for c_node in controlouts:
    c_label = getText(c_node, 'label')
    fc.write(T + 'if (dest == x->'+c_label+'){'+'\n')
    fc.write(T*2+'clock_delay(x->p_'+c_label+'Clock, 
             index*1000/XSPIF_GET_SAMPLE_RATE());'+'\n')
    fc.write(T*2+'x->'+c_label+'Value = value;'+'\n')
    fc.write(T+'}' + '\n')
fc.write('}' + '\n')
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent Then, just before writing the process callback, we need to re-define 
our macro, so that it set the relevant clock, instead of calling \verb|float\_outlet|:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
fc.write('// Macro for control outputs in the perform method : use clock' + '\n')
fc.write('#undef XSPIF_CONTROLOUT'+ '\n'
         '#define XSPIF_CONTROLOUT(dest, index, value)('
         + pluginLabelTilde+'_controlouts(x, dest,
           index*1000/XSPIF_GET_SAMPLE_RATE(), value)) '+ '\n')
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent In the instantiate callback, we need to create the outlets 
and the clocks corresponding to the controlout outlets:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
fc.write('void *' + pluginLabelTilde + '_new('
         + 't_symbol *s, int argc, t_atom *argv)' + '\n'
         + '{' +  '\n'
               (...)
    for c_node in controlouts:
        c_label = getText(c_node, 'label')
        fc.write(T + '//  controlout ' + c_label + '\n')
        fc.write(T+'x->'+c_label+' = outlet_new(&x->x_obj,  &s_float);'+'\n')
        fc.write(T+'x->p_'+c_label+'Clock = 
                    clock_new(x, (t_method)'+pluginLabelTilde+'_'+c_label+');'+'\n')
               (...)
----------------------- [end Python code] -----------------------
\end{verbatim}

\noindent In the deinstantiate callback, we need to destroy the outlets 
and the clocks:

\begin{verbatim}
---------------------- [begin Python code] ----------------------
if (deinstantiate  or [] != controlouts):
    fc.write('\n' + '\n' + separator)
    fc.write('// Plugin cleanup method' + '\n')
    fc.write('void ' + pluginLabelTilde + '_free('+t_pluginLabel+' *x){' + '\n')
               (...)
    for c_node in controlouts:
        c_label = getText(c_node, 'label')
        fc.write(T+'clock_free(x->p_'+c_label+'Clock);'+'\n')
               (...)
----------------------- [end Python code] -----------------------
\end{verbatim}
